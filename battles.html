<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BrawlSpheres // SIMULATION</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
:root {
    --bg-dark: #09090b;
    --panel-bg: rgba(20, 20, 25, 0.9);
    --panel-border: 1px solid rgba(255, 255, 255, 0.1);
    --accent-blue: #00d2ff;
    --accent-purple: #9d00ff;
    --accent-red: #ff2a6d;
    --accent-green: #00ff9d;
    --text-main: #ffffff;
    --text-muted: #8b9bb4;
    --editor-width: 380px;
}

* { box-sizing: border-box; }

body {
    margin: 0; height: 100vh; font-family: 'Rajdhani', sans-serif;
    background-color: var(--bg-dark); color: var(--text-main); overflow: hidden;
}

/* Background Effects */
.grid-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background-image: 
        linear-gradient(rgba(0, 210, 255, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 210, 255, 0.03) 1px, transparent 1px);
    background-size: 40px 40px; z-index: -2; pointer-events: none;
}
.bg-orb {
    position: absolute; border-radius: 50%; filter: blur(80px); z-index: -3; opacity: 0.3;
    animation: floatOrb 10s infinite alternate ease-in-out;
}
.orb-1 { top: -10%; left: -10%; width: 50vw; height: 50vw; background: var(--accent-purple); }
.orb-2 { bottom: -10%; right: -10%; width: 40vw; height: 40vw; background: var(--accent-blue); animation-delay: -5s; }
@keyframes floatOrb { from { transform: translate(0,0); } to { transform: translate(30px, 30px); } }

/* Layout */
.root {
    display: flex; height: 100vh; padding: 20px; gap: 20px;
    backdrop-filter: blur(2px);
}

/* Arena */
#arenaWrap {
    flex: 1; display: flex; flex-direction: column; align-items: center;
    justify-content: center; position: relative;
}
#arena {
    position: relative; background: rgba(0, 0, 0, 0.5);
    border: 2px solid var(--accent-blue);
    box-shadow: 0 0 20px rgba(0, 210, 255, 0.1);
    overflow: hidden; touch-action: none; user-select: none; border-radius: 4px;
}
#stormCanvas { position: absolute; left: 0; top: 0; z-index: 10; pointer-events: none; }

/* Ball DOM */
.ball-el {
    position: absolute; z-index: 20; display: flex; align-items: center; justify-content: center;
    font-weight: 700; box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.6);
}
.ball-el.dead { filter: grayscale(100%) brightness(0.4); opacity: 0.4; z-index: 5; border:none;}

/* Health Displays */
.hp-text {
    position: absolute; font-size: 14px; top: -20px; left: 50%;
    transform: translateX(-50%); pointer-events: none; z-index: 30;
    color: #fff; text-shadow: 0 1px 2px #000; font-weight: bold; white-space: nowrap;
}
.hp-bar-wrap {
    position: absolute; top: -12px; left: 50%; transform: translateX(-50%);
    width: 40px; height: 6px; background: #333; border: 1px solid #000;
    z-index: 30; pointer-events: none;
}
.hp-bar-fill { height: 100%; background: #0f0; transition: width 0.1s linear; }
.hp-bar-val {
    position: absolute; top: -14px; width: 100%; text-align: center;
    font-size: 10px; color: #fff; text-shadow: 0 1px 2px #000;
}

/* Weapon DOM */
.weapon-el {
    position: absolute; width: 8px; height: 8px; 
    background: #fff; border-radius: 50%;
    box-shadow: 0 0 8px var(--accent-purple);
    z-index: 19; pointer-events: none;
}

/* Powerups DOM */
.powerup-el {
    position: absolute; z-index: 15; display: flex; align-items: center; justify-content: center;
    font-size: 12px; color: #000; font-weight: bold; opacity: 0.9;
    animation: pulse 1.5s infinite ease-in-out;
}
@keyframes pulse { 0%,100%{transform:scale(1);} 50%{transform:scale(1.1);} }

/* Shapes */
.shape-square { border-radius: 2px; }
.shape-diamond { transform: rotate(45deg); border-radius: 2px; }
.shape-circle { border-radius: 50%; }
.shape-hexagon { clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%); }
.shape-plus { clip-path: polygon(35% 0, 65% 0, 65% 35%, 100% 35%, 100% 65%, 65% 65%, 65% 100%, 35% 100%, 35% 65%, 0 65%, 0 35%, 35% 35%); }

/* Editor Panel */
#editor {
    width: var(--editor-width); background: var(--panel-bg);
    border: var(--panel-border); border-radius: 12px;
    display: flex; flex-direction: column; padding: 20px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5); z-index: 50;
}

/* Header & Nav */
.editor-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
.editor-header h2 { margin: 0; font-size: 1.5rem; text-transform: uppercase; letter-spacing: 2px; }
.editor-header h2 span { color: var(--accent-blue); }

.tabs { display: flex; gap: 5px; margin-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.1); }
.tab {
    flex: 1; padding: 10px; background: transparent; border: none;
    color: var(--text-muted); font-weight: bold; cursor: pointer;
    text-transform: uppercase; letter-spacing: 1px; transition: 0.2s;
    border-bottom: 2px solid transparent;
}
.tab:hover { color: #fff; background: rgba(255,255,255,0.05); }
.tab.active { color: var(--accent-blue); border-bottom-color: var(--accent-blue); }

/* Content Area */
.subWrap { flex: 1; overflow-y: auto; padding-right: 5px; margin-bottom: 10px; }
.subWrap::-webkit-scrollbar { width: 4px; }
.subWrap::-webkit-scrollbar-thumb { background: #444; border-radius: 2px; }

h4 {
    color: var(--accent-purple); text-transform: uppercase; font-size: 0.9rem;
    border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; margin: 20px 0 10px 0;
}
.subCat { display: none; }
.subCat.active { display: block; }

/* Controls */
.control { margin-bottom: 12px; padding-left: 8px; } /* Added left padding */
label.setting-label { display: block; color: var(--text-muted); font-size: 0.85rem; margin-bottom: 4px; }
input, select {
    background: rgba(0,0,0,0.4); border: 1px solid #444; color: #fff;
    padding: 8px; border-radius: 4px; width: 100%; font-family: inherit;
}
input:focus, select:focus { outline: none; border-color: var(--accent-blue); }
input[type=checkbox] { width: auto; }

/* Color & Lists */
.color-row { display: flex; align-items: center; gap: 10px; }
.color-swatch { width: 100%; height: 32px; border-radius: 4px; border: 1px solid #fff; cursor: pointer; }

/* Locate this around line 490 */
.item-list { 
    background: rgba(0,0,0,0.3); 
    border-radius: 6px; 
    padding: 8px; /* Slightly increased padding for better looks */
    max-height: 200px; 
    min-height: 40px; /* <--- ADD THIS: Prevents the list from disappearing when empty */
    overflow-y: auto; 
    margin-bottom: 10px; 
    border: 1px dashed rgba(255, 255, 255, 0.05); /* Optional: Adds a subtle "empty" border */
}
.item-row {
    display: flex; align-items: center; gap: 10px; padding: 6px;
    background: rgba(255,255,255,0.03); margin-bottom: 4px; border-radius: 4px;
}
.item-icon { width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 10px; color:#000; font-weight:bold; }
.item-name { flex: 1; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

.action-btn {
    width: 24px; height: 24px; border: 1px solid #444; background: #222;
    color: #aaa; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center;
}
.action-btn:hover { border-color: var(--accent-blue); color: #fff; }

/* Main Buttons */
.editorFooterInner { display: flex; gap: 10px; margin-top: auto; }
.btn {
    flex: 1; padding: 12px; border: none; border-radius: 4px;
    font-family: inherit; font-weight: 700; text-transform: uppercase; cursor: pointer;
    background: var(--accent-blue); color: #000; transition: 0.2s;
}
.btn:hover { filter: brightness(1.2); box-shadow: 0 0 15px var(--accent-blue); }
.btn.secondary { background: transparent; border: 1px solid var(--text-muted); color: var(--text-muted); }
.btn.secondary:hover { border-color: #fff; color: #fff; }

/* --- BULLETPROOF TOGGLE CSS --- */
/* 1. THE CONTAINER: Prevents the toggle from being pushed or squished */
.toggle-row { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    padding: 8px 0;
    width: 100%;
}

/* 2. THE TRACK: Set a fixed size and prevent shrinking */
.toggle-switch { 
    width: 44px;  
    height: 22px; 
    background: #333; 
    border-radius: 20px; 
    cursor: pointer;
    transition: background 0.3s; 
    flex-shrink: 0; /* CRITICAL: This prevents the "no space" bug */
    margin: 0;
    outline: none;
    box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
}
/* Overlay & Modals */
#customiserModal, #winnerModal {
    position: fixed; inset: 0; z-index: 100; display: none;
    align-items: center; justify-content: center; background: rgba(0,0,0,0.85); backdrop-filter: blur(8px);
}
#customiser {
    width: 800px; max-width: 95%; height: 550px; background: #111;
    border: 1px solid var(--accent-purple); display: flex; gap: 20px; padding: 20px;
    box-shadow: 0 0 50px rgba(157, 0, 255, 0.2);
}
.custom-left { width: 220px; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(255,255,255,0.02); border-radius: 8px; }
.preview-ball { width: 140px; height: 140px; border-radius: 50%; box-shadow: 0 0 30px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; font-size: 2rem; border: 2px solid rgba(255,255,255,0.2); position: relative; }
.custom-right { flex: 1; display: flex; flex-direction: column; }

/* Grids */
.grid-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); gap: 8px; margin-top: 5px; }
.grid-item { height: 40px; border: 1px solid #333; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: 0.2s; position: relative;}
.grid-item:hover { border-color: #fff; }
.grid-item.active { border-color: var(--accent-purple); box-shadow: 0 0 10px var(--accent-purple); }
.grid-item.locked { background: #000; opacity: 0.4; cursor: not-allowed; }
.grid-item.locked::after { content: 'ðŸ”’'; font-size: 10px; position: absolute; }

/* Winner Screen */
.winner-content {
    text-align: center; color: #fff; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
.winner-trophy { font-size: 80px; color: gold; margin-bottom: 20px; filter: drop-shadow(0 0 20px gold); }
.winner-name { font-size: 3rem; font-weight: 800; text-transform: uppercase; margin: 0; color: var(--accent-blue); text-shadow: 0 0 20px var(--accent-blue); }
@keyframes popIn { from{transform:scale(0.5); opacity:0;} to{transform:scale(1); opacity:1;} }

/* Footer Links */
#discordLink {
    position: fixed; bottom: 20px; left: 20px; z-index: 100;
    color: #5865F2; text-decoration: none; font-weight: bold;
    display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.6);
    padding: 8px 12px; border-radius: 20px; border: 1px solid #5865F2;
    transition: 0.2s;
}
#discordLink:hover { background: #5865F2; color: #fff; }

#menuLink {
    position: fixed; top: 20px; left: 20px; z-index: 100;
    color: #fff; text-decoration: none; font-weight: bold;
    display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.6);
    padding: 8px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.3);
}
#menuLink:hover { background: #fff; color: #000; }

@media (max-width: 900px) {
    .root { flex-direction: column-reverse; overflow-y: auto; padding: 10px; }
    #editor { width: 100%; flex: none; }
    #arenaWrap { min-height: 400px; }
    #discordLink { position: static; margin-top: 20px; width: fit-content; }
}
</style>
</head>
<body>

    <div class="grid-overlay"></div>
    <div class="bg-orb orb-1"></div>
    <div class="bg-orb orb-2"></div>

    <a href="https://endercivil.github.io" id="menuLink"><i class="fa-solid fa-house"></i> Main Menu</a>

    <div id="page" class="root">
        <div id="arenaWrap">
            <div id="arena"></div>
        </div>

        <div id="editor">
            <div id="editorOverlay"></div>
            
            <div class="editor-header">
                <h2>BATTLES <span>Config</span></h2>
                <div style="font-size: 0.8rem; color: #666;">V 0.7</div>
            </div>

            <div class="tabs">
                <button class="tab active" data-target="spheres">Spheres</button>
                <button class="tab" data-target="arenaTab">Arena</button>
                <button class="tab" data-target="misc">System</button>
            </div>

            <div class="subWrap">
                <div class="subCat active" id="spheres">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <h4 style="margin:0; border:none;">Active Units</h4>
                        <button id="addBall" class="action-btn" style="width:auto; padding:0 8px; border-color:var(--accent-blue); color:var(--accent-blue);">
                            <i class="fa-solid fa-plus"></i> &nbsp;ADD
                        </button>
                    </div>
                    <div class="control" style="margin-top:10px;">
                        <div class="item-list" id="ballList"></div>
                    </div>
                </div>

                <div class="subCat" id="arenaTab">
                    <div class="toggle-row">
                        <h4 style="margin:0; border:none;"><i class="fa-solid fa-hurricane"></i> Storm</h4>
                        <input type="checkbox" id="stormToggle" class="toggle-switch" checked>
                    </div>
                    <div id="stormSettings" style="display:block;">
                        <div class="control">
                            <label class="setting-label">Storm Color</label>
                            <div class="color-row">
                                <div class="color-swatch" id="stormSwatch"></div>
                                <input id="stormColor" type="color" value="#ff2a6d" style="display:none">
                            </div>
                        </div>
                        <div class="control">
                            <label class="setting-label">Initial Coverage (0% = Safe, 100% = No Safe Zone)</label>
                            <input id="stormStartPct" type="range" min="0" max="100" value="0">
                        </div>
                        <div class="control">
                            <label class="setting-label">Damage Per Second</label>
                            <input id="stormDPS" type="number" min="0" value="10">
                        </div>
                        <div class="control">
                            <label class="setting-label">Close Time (s)</label>
                            <input id="stormShrink" type="number" min="1" value="30">
                        </div>
                    </div>

                    <div class="toggle-row" style="margin-top:20px;">
                        <h4 style="margin:0; border:none;"><i class="fa-solid fa-bolt"></i> Powerups</h4>
                        <input type="checkbox" id="powerupToggle" class="toggle-switch">
                    </div>
                    <div id="powerupSettings" style="display:none; margin-top:10px;">
                         <div style="display:flex; justify-content:space-between; align-items:center;">
                            <label class="setting-label">Spawn List</label>
                            <button id="addPowerup" class="action-btn" style="width:auto; padding:0 6px;">
                                <i class="fa-solid fa-plus"></i> ADD
                            </button>
                        </div>
                        <div class="control">
                            <div class="item-list" id="powerupList"></div>
                        </div>
                    </div>

                    <h4><i class="fa-solid fa-triangle-exclamation"></i> Hazards</h4>
                    <div class="control">
                        <label class="setting-label">Wall Damage</label>
                        <input id="wallDamage" type="number" value="10" min="0">
                    </div>
                    <div class="control">
                        <label class="setting-label">Gravity</label>
                        <input id="gravity" type="number" step="0.05" value="0">
                    </div>
                    <div class="control">
                        <label class="setting-label">Border Hex</label>
                        <div class="color-row">
                            <div class="color-swatch" id="borderSwatch"></div>
                            <input id="borderColor" type="color" value="#00d2ff" style="display:none">
                        </div>
                    </div>
                </div>

                <div class="subCat" id="misc">
                    <h4>Interface</h4>
                    <div class="control">
                        <label class="setting-label">Health Display</label>
                        <select id="healthDisplay">
                            <option value="onBall">On Unit (Number)</option>
                            <option value="bar">Bar Only</option>
                            <option value="barNumber">Bar + Value</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="editorFooter">
                <div class="editorFooterInner">
                    <button id="clearBtn" class="btn secondary" style="flex: 1;"><i class="fa-solid fa-trash"></i></button>
                    <button id="startStop" class="btn" style="flex: 3; z-index:75;">START</button>
                </div>
            </div>
        </div>
    </div>

    <a href="https://discord.gg/BPvWwaaQMH" target="_blank" id="discordLink">
        <i class="fa-brands fa-discord"></i> Join Discord
    </a>

    <div id="customiserModal">
        <div id="customiser">
            <div class="custom-left">
                <div class="preview-ball" id="customPreview"></div>
                <div id="prevLabel" style="margin-top:10px; color: #666; font-size: 0.8rem; text-transform: uppercase;">Preview</div>
            </div>
            <div class="custom-right">
                <div class="custom-tabs">
                    </div>
                <div class="custom-body" id="customBody" style="flex:1; overflow:auto;"></div>
                <div class="custom-actions">
                    <button id="cancelCustom" class="btn secondary">Cancel</button>
                    <button id="confirmCustom" class="btn" style="background: var(--accent-purple); color: #fff;">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <div id="winnerModal">
        <div class="winner-content">
            <div class="winner-trophy"><i class="fa-solid fa-trophy"></i></div>
            <h2 style="margin:0; font-size:1.2rem; color:#aaa;">VICTORY ROYALE</h2>
            <div class="winner-name" id="winnerName">PLAYER 1</div>
            <button id="playAgainBtn" class="btn" style="margin-top:30px; padding: 15px 40px; font-size:1.2rem;">RESTART</button>
        </div>
    </div>

<script>
/* ---- DOM Refs ---- */
const arena = document.getElementById('arena');
const editor = document.getElementById('editor');
const editorOverlay = document.getElementById('editorOverlay');
const startStopBtn = document.getElementById('startStop');
const clearBtn = document.getElementById('clearBtn');
const tabs = document.querySelectorAll('.tab');
const subCats = document.querySelectorAll('.subCat');

/* ---- Inputs ---- */
const stormToggle = document.getElementById('stormToggle');
const stormSettings = document.getElementById('stormSettings');
const stormColorInput = document.getElementById('stormColor');
const stormSwatch = document.getElementById('stormSwatch');
const stormStartPctInput = document.getElementById('stormStartPct');
const stormDPSInput = document.getElementById('stormDPS');
const stormShrinkInput = document.getElementById('stormShrink');
const powerupToggle = document.getElementById('powerupToggle');
const powerupSettings = document.getElementById('powerupSettings');
const healthDisplaySelect = document.getElementById('healthDisplay');
const wallDamageInput = document.getElementById('wallDamage');
const gravityInput = document.getElementById('gravity');
const borderColorInput = document.getElementById('borderColor');
const borderSwatch = document.getElementById('borderSwatch');

/* ---- Modals ---- */
const customiserModal = document.getElementById('customiserModal');
const customBody = document.getElementById('customBody');
const customPreview = document.getElementById('customPreview');
const cancelCustom = document.getElementById('cancelCustom');
const confirmCustom = document.getElementById('confirmCustom');
const winnerModal = document.getElementById('winnerModal');
const winnerNameEl = document.getElementById('winnerName');
const playAgainBtn = document.getElementById('playAgainBtn');

/* ---- State ---- */
let balls = [];
let powerups = [];
let ballCounter = 0;
let animId = null;
let gameRunning = false;
let stormCanvas = null, stormCtx = null;
let stormRadius = 0;
let maxArenaSize = 0;
let stormStartTime = 0;

/* ---- Edit State ---- */
let editType = null; // 'ball' or 'powerup'
let editIndex = null;
let editCopy = null;

/* ---- Config Data ---- */
const COLORS = [
    { c: '#ff2a6d', lock: false }, { c: '#00d2ff', lock: false }, // Primary/Secondary
    { c: '#9d00ff', lock: true }, { c: '#ffd23b', lock: true }, 
    { c: '#ffffff', lock: true }, { c: '#ff9900', lock: true },
    { c: '#00ff9d', lock: true }, { c: '#5865f2', lock: true }
];
const SHAPES = [
    { id: 'shape-circle', icon: 'fa-circle', lock: false },
    { id: 'shape-square', icon: 'fa-square', lock: false },
    { id: 'shape-diamond', icon: 'fa-diamond', lock: false },
    { id: 'shape-hexagon', icon: 'fa-cube', lock: true },
    { id: 'shape-plus', icon: 'fa-plus', lock: true }
];

/* ---- Initialization ---- */
function init(){
    ensureCanvas();
    setupSwatches();
    applyLayout();
    
    // Default Spawns
    addBallLogic(); addBallLogic();
    renderLists();

    window.addEventListener('resize', ()=>{ applyLayout(); ensureCanvas(); });
    
    // Toggles
    stormToggle.addEventListener('change', ()=> stormSettings.style.display = stormToggle.checked ? 'block' : 'none');
    powerupToggle.addEventListener('change', ()=> powerupSettings.style.display = powerupToggle.checked ? 'block' : 'none');
    
    // Tabs
    tabs.forEach(t => t.addEventListener('click', ()=>{
        tabs.forEach(x=>x.classList.remove('active')); t.classList.add('active');
        subCats.forEach(s => s.classList.remove('active'));
        document.getElementById(t.dataset.target).classList.add('active');
    }));

    // Buttons
    document.getElementById('addBall').addEventListener('click', ()=> { if(!gameRunning) { addBallLogic(); renderLists(); } });
    document.getElementById('addPowerup').addEventListener('click', ()=> { if(!gameRunning) { addPowerupLogic(); renderLists(); } });
    document.getElementById('clearBtn').addEventListener('click', ()=> { if(!gameRunning) { balls.forEach(b=>b.remove()); balls=[]; ballCounter=0; renderLists(); } });
    
    startStopBtn.addEventListener('click', toggleGame);
    playAgainBtn.addEventListener('click', resetGame);
}

function ensureCanvas(){
    if(!stormCanvas){
        stormCanvas = document.createElement('canvas');
        stormCanvas.id = 'stormCanvas';
        arena.appendChild(stormCanvas);
        stormCtx = stormCanvas.getContext('2d');
    }
    stormCanvas.width = arena.clientWidth;
    stormCanvas.height = arena.clientHeight;
}

function applyLayout(){
    const isMobile = window.innerWidth < 900;
    if (isMobile) {
        arena.style.width = '100%'; arena.style.height = '400px';
    } else {
        const sidebarW = editor.offsetWidth + 40;
        const availableW = window.innerWidth - sidebarW;
        const availableH = window.innerHeight - 40;
        const size = Math.min(availableW, availableH) - 20;
        arena.style.width = size + 'px'; arena.style.height = size + 'px';
    }
    ensureCanvas();
    arena.style.borderColor = borderColorInput.value;
    maxArenaSize = Math.min(arena.clientWidth, arena.clientHeight) / 2 * 1.42; // Corners
}

function setupSwatches(){
    const link = (swatch, input) => {
        swatch.style.backgroundColor = input.value;
        swatch.onclick = () => input.click();
        input.oninput = () => { swatch.style.backgroundColor = input.value; if(input.id==='borderColor') arena.style.borderColor = input.value; };
    };
    link(stormSwatch, stormColorInput);
    link(borderSwatch, borderColorInput);
}

/* ---- Game Entities ---- */
class Ball {
    constructor(name){
        this.name = name;
        this.color = `hsl(${Math.random()*360} 70% 50%)`;
        this.size = 36;
        this.maxHp = 100;
        this.hp = 100;
        this.vx = 0; this.vy = 0;
        this.dead = false;
        
        this.weapon = { damage: 10, speed: 0.1, dist: 28, angle: 0 }; // Orbit mechanics
        
        const pos = getSafePos(this.size);
        this.x = pos.x; this.y = pos.y;

        // DOM
        this.el = document.createElement('div');
        this.el.className = 'ball-el';
        this.el.style.width = this.el.style.height = this.size + 'px';
        this.el.style.backgroundColor = this.color;
        this.el.style.borderRadius = '50%';
        
        // HP Text (onBall)
        this.hpText = document.createElement('div');
        this.hpText.className = 'hp-text';
        this.el.appendChild(this.hpText);

        // HP Bar (Bar / BarNum)
        this.hpBarWrap = document.createElement('div');
        this.hpBarWrap.className = 'hp-bar-wrap';
        this.hpBarFill = document.createElement('div');
        this.hpBarFill.className = 'hp-bar-fill';
        this.hpBarVal = document.createElement('div');
        this.hpBarVal.className = 'hp-bar-val';
        this.hpBarWrap.appendChild(this.hpBarFill);
        this.hpBarWrap.appendChild(this.hpBarVal);
        this.el.appendChild(this.hpBarWrap);

        // Weapon
        this.weaponEl = document.createElement('div');
        this.weaponEl.className = 'weapon-el';
        arena.appendChild(this.weaponEl); // Append to arena to handle z-index better or relative
        // Actually, for orbit, easier to append to Ball if we rotate ball? 
        // No, ball shouldn't spin. Append weapon to ball and absolute pos it.
        this.el.appendChild(this.weaponEl);

        arena.appendChild(this.el);
        this.updateDOM();
    }

    launch(){
        const speed = (Math.random()*3)+2;
        const a = Math.random()*Math.PI*2;
        this.vx = Math.cos(a)*speed; this.vy = Math.sin(a)*speed;
    }

    step(){
        if(this.dead) return;
        this.vy += parseFloat(gravityInput.value)||0;
        this.x += this.vx; this.y += this.vy;
        
        // Walls
        const w = arena.clientWidth, h = arena.clientHeight;
        const dmg = parseFloat(wallDamageInput.value)||0;
        if(this.x<=0){ this.x=0; this.vx*=-1; this.hp-=dmg; }
        if(this.x+this.size>=w){ this.x=w-this.size; this.vx*=-1; this.hp-=dmg; }
        if(this.y<=0){ this.y=0; this.vy*=-1; this.hp-=dmg; }
        if(this.y+this.size>=h){ this.y=h-this.size; this.vy*=-1; this.hp-=dmg; }

        // Weapon Orbit
        this.weapon.angle += this.weapon.speed;
        const rad = this.size/2 + 10; // orbit distance
        const wx = (this.size/2 - 4) + Math.cos(this.weapon.angle) * rad;
        const wy = (this.size/2 - 4) + Math.sin(this.weapon.angle) * rad;
        this.weaponEl.style.left = wx + 'px';
        this.weaponEl.style.top = wy + 'px';

        // Check death
        if(this.hp <= 0){
            this.dead = true;
            this.vx=0; this.vy=0;
            this.el.classList.add('dead');
            this.weaponEl.style.display = 'none';
            renderLists();
            checkWinCondition();
        }
        this.updateDOM();
    }

    updateDOM(){
        this.el.style.left = this.x + 'px';
        this.el.style.top = this.y + 'px';
        
        // Health Displays
        const mode = healthDisplaySelect.value;
        const hpInt = Math.max(0, Math.round(this.hp));
        
        this.hpText.style.display = (mode === 'onBall') ? 'block' : 'none';
        this.hpText.textContent = hpInt;
        
        if(mode === 'bar' || mode === 'barNumber') {
            this.hpBarWrap.style.display = 'block';
            const pct = (this.hp / this.maxHp) * 100;
            this.hpBarFill.style.width = Math.max(0, pct) + '%';
            this.hpBarFill.style.background = pct > 50 ? '#0f0' : (pct > 25 ? '#ff0' : '#f00');
            
            if(mode === 'barNumber'){
                this.hpBarVal.style.display = 'block';
                this.hpBarVal.textContent = hpInt;
            } else {
                this.hpBarVal.style.display = 'none';
            }
        } else {
            this.hpBarWrap.style.display = 'none';
        }
    }

    remove(){ if(this.el.parentNode) this.el.parentNode.removeChild(this.el); }
}

class Powerup {
    constructor(type){
        this.type = type || 'HEAL'; // HEAL, RAGE, SPEED
        this.color = '#00ff9d';
        this.shape = 'shape-plus'; // css class
        this.size = 30;
        this.x = 0; this.y = 0;
        
        const pos = getSafePos(this.size);
        this.x = pos.x; this.y = pos.y;
        
        this.el = document.createElement('div');
        this.el.className = `powerup-el ${this.shape}`;
        this.el.style.width = this.el.style.height = this.size + 'px';
        this.el.style.left = this.x+'px'; this.el.style.top = this.y+'px';
        this.el.style.backgroundColor = this.color;
        
        // Icon based on type
        const icon = document.createElement('i');
        icon.className = this.getIcon();
        this.el.appendChild(icon);
        
        arena.appendChild(this.el);
    }
    
    getIcon(){
        if(this.type === 'HEAL') return 'fa-solid fa-heart';
        if(this.type === 'RAGE') return 'fa-solid fa-fire';
        if(this.type === 'SPEED') return 'fa-solid fa-bolt';
        return '';
    }

    remove(){ if(this.el.parentNode) this.el.remove(); }
}

/* ---- Logic Helpers ---- */
function addBallLogic(){
    ballCounter++;
    balls.push(new Ball('Unit '+ballCounter));
}
function addPowerupLogic(){
    powerups.push(new Powerup('HEAL'));
}
function getSafePos(size){
    let tries=0;
    while(tries++<500){
        const x = Math.random()*(arena.clientWidth-size);
        const y = Math.random()*(arena.clientHeight-size);
        // Distance check from balls
        const ok = !balls.some(b => Math.hypot(b.x-x, b.y-y) < 50);
        if(ok) return {x,y};
    }
    return {x:0, y:0};
}

/* ---- Game Loop ---- */
function toggleGame(){
    if(!gameRunning){
        if(balls.length < 2){ alert('Need 2+ Units'); return; }
        gameRunning = true;
        setEditorLocked(true);
        startStopBtn.textContent = 'ABORT';
        startStopBtn.style.background = 'var(--accent-red)';
        
        // Init Round
        balls.forEach(b => {
            b.dead = false; b.hp = b.maxHp; b.el.classList.remove('dead');
            b.weaponEl.style.display = 'block';
            b.launch();
            b.updateDOM();
        });
        
        // Powerups (if toggle off, remove them temporarily? No, just keep static)
        if(powerupToggle.checked){
            // Respawn powerups if needed or keep existing? Let's keep existing logic.
        }

        // Storm
        if(stormToggle.checked){
            stormStartTime = Date.now();
            const diag = Math.hypot(arena.clientWidth, arena.clientHeight)/2;
            const pct = parseInt(stormStartPctInput.value);
            // 0% = Full Safe (Radius = diag), 100% = 0 Safe
            stormRadius = diag * (1 - (pct/100));
        } else {
            stormRadius = 99999;
        }

        loop();
    } else {
        stopGame();
    }
}

function stopGame(){
    gameRunning = false;
    if(animId) cancelAnimationFrame(animId);
    setEditorLocked(false);
    startStopBtn.textContent = 'INITIALIZE';
    startStopBtn.style.background = 'var(--accent-blue)';
    if(stormCtx) stormCtx.clearRect(0,0,stormCanvas.width, stormCanvas.height);
}

function resetGame(){
    winnerModal.style.display = 'none';
    stopGame(); // Unlocks editor
    // Reset positions?
    balls.forEach(b => {
        const pos = getSafePos(b.size);
        b.x = pos.x; b.y = pos.y;
        b.hp = b.maxHp;
        b.updateDOM();
    });
}

function checkWinCondition(){
    const alive = balls.filter(b => !b.dead);
    if(alive.length <= 1 && balls.length > 1){
        setTimeout(() => {
            if(!gameRunning) return;
            gameRunning = false;
            winnerNameEl.textContent = alive.length ? alive[0].name : 'DRAW';
            winnerModal.style.display = 'flex';
        }, 1000);
    }
}

function loop(){
    if(!gameRunning) return;
    
    // Storm Logic
    if(stormToggle.checked){
        const elapsed = (Date.now() - stormStartTime)/1000;
        const dur = parseFloat(stormShrinkInput.value) || 30;
        const diag = Math.hypot(arena.clientWidth, arena.clientHeight)/2;
        const startR = diag * (1 - (parseInt(stormStartPctInput.value)/100));
        
        // Linearly decrease radius
        stormRadius = Math.max(0, startR - (elapsed * (startR/dur)));
        renderStorm();
    }

    physics();
    animId = requestAnimationFrame(loop);
}

function physics(){
    // Collide Balls
    for(let i=0; i<balls.length; i++){
        for(let j=i+1; j<balls.length; j++){
            const A = balls[i], B = balls[j];
            if(A.dead || B.dead) continue;
            
            const dx = (B.x+B.size/2) - (A.x+A.size/2);
            const dy = (B.y+B.size/2) - (A.y+A.size/2);
            const dist = Math.hypot(dx, dy);
            const min = (A.size+B.size)/2;
            
            if(dist < min){
                // Push
                const angle = Math.atan2(dy, dx);
                const push = min - dist;
                const ax = Math.cos(angle)*push*0.5;
                const ay = Math.sin(angle)*push*0.5;
                A.x -= ax; A.y -= ay;
                B.x += ax; B.y += ay;
                
                // Bounce
                const tx = Math.cos(angle), ty = Math.sin(angle);
                const dp = (B.vx-A.vx)*tx + (B.vy-A.vy)*ty;
                if(dp < 0){
                    A.vx += tx * dp * 0.9; A.vy += ty * dp * 0.9;
                    B.vx -= tx * dp * 0.9; B.vy -= ty * dp * 0.9;
                }
            }
            
            // Weapon Hit (Orbiting Point vs Circle)
            const checkWeapon = (attacker, victim) => {
                const rad = attacker.size/2 + 10;
                const wx = (attacker.x + attacker.size/2) + Math.cos(attacker.weapon.angle)*rad;
                const wy = (attacker.y + attacker.size/2) + Math.sin(attacker.weapon.angle)*rad;
                
                const vcx = victim.x + victim.size/2;
                const vcy = victim.y + victim.size/2;
                
                if(Math.hypot(wx-vcx, wy-vcy) < victim.size/2 + 4){
                    // Hit
                    const knockX = (vcx - wx); const knockY = (vcy - wy);
                    const mag = Math.hypot(knockX, knockY) || 1;
                    victim.vx += (knockX/mag)*2; victim.vy += (knockY/mag)*2;
                    victim.hp -= attacker.weapon.damage * 0.1; 
                }
            };
            checkWeapon(A, B);
            checkWeapon(B, A);
        }
    }
    
    // Powerup Collision
    if(powerupToggle.checked){
        balls.forEach(b => {
            if(b.dead) return;
            const cx = b.x + b.size/2, cy = b.y + b.size/2;
            for(let i=powerups.length-1; i>=0; i--){
                const p = powerups[i];
                const px = p.x + p.size/2, py = p.y + p.size/2;
                if(Math.hypot(cx-px, cy-py) < (b.size/2 + p.size/2)){
                    // Effect
                    if(p.type === 'HEAL') b.hp = Math.min(b.maxHp, b.hp + 30);
                    if(p.type === 'RAGE') b.weapon.damage += 10;
                    if(p.type === 'SPEED') { b.vx*=1.5; b.vy*=1.5; }
                    
                    p.remove();
                    powerups.splice(i, 1);
                    renderLists();
                }
            }
        });
    }

    // Move & Storm Dmg
    const center = { x: arena.clientWidth/2, y: arena.clientHeight/2 };
    balls.forEach(b => {
        b.step();
        if(stormToggle.checked && !b.dead){
            const dist = Math.hypot((b.x+b.size/2)-center.x, (b.y+b.size/2)-center.y);
            if(dist > stormRadius){
                b.hp -= (parseFloat(stormDPSInput.value)||0) / 60;
            }
        }
    });
}

function renderStorm(){
    const w = stormCanvas.width, h = stormCanvas.height;
    stormCtx.clearRect(0,0,w,h);
    
    // Fill Screen with Storm Color (Semi transparent)
    stormCtx.fillStyle = hexToRgba(stormColorInput.value, 0.3);
    stormCtx.fillRect(0,0,w,h);
    
    // Cut out Safe Zone
    stormCtx.globalCompositeOperation = 'destination-out';
    stormCtx.beginPath();
    stormCtx.arc(w/2, h/2, Math.max(0, stormRadius), 0, Math.PI*2);
    stormCtx.fill();
    
    // Draw Border
    stormCtx.globalCompositeOperation = 'source-over';
    stormCtx.beginPath();
    stormCtx.lineWidth = 3;
    stormCtx.strokeStyle = stormColorInput.value;
    stormCtx.arc(w/2, h/2, Math.max(0, stormRadius), 0, Math.PI*2);
    stormCtx.stroke();
}

/* ---- UI / Customiser ---- */
function renderLists(){
    const bl = document.getElementById('ballList');
    bl.innerHTML = '';
    balls.forEach((b,i) => {
        const row = document.createElement('div');
        row.className = 'item-row' + (b.dead?' dead':'');
        row.innerHTML = `
            <div class="item-icon" style="background:${b.color}">${b.name.charAt(0)}</div>
            <div class="item-name">${b.name}</div>
            <button class="action-btn" onclick="openCustomiser('ball', ${i})"><i class="fa-solid fa-pen"></i></button>
            <button class="action-btn" onclick="removeBall(${i})"><i class="fa-solid fa-times"></i></button>
        `;
        bl.appendChild(row);
    });

    const pl = document.getElementById('powerupList');
    pl.innerHTML = '';
    powerups.forEach((p,i) => {
        const row = document.createElement('div');
        row.className = 'item-row';
        row.innerHTML = `
            <div class="item-icon" style="background:${p.color}"><i class="${p.getIcon()}"></i></div>
            <div class="item-name">${p.type}</div>
            <button class="action-btn" onclick="openCustomiser('powerup', ${i})"><i class="fa-solid fa-pen"></i></button>
            <button class="action-btn" onclick="removePowerup(${i})"><i class="fa-solid fa-times"></i></button>
        `;
        pl.appendChild(row);
    });
}
function removeBall(i){ if(gameRunning)return; balls[i].remove(); balls.splice(i,1); renderLists(); }
function removePowerup(i){ if(gameRunning)return; powerups[i].remove(); powerups.splice(i,1); renderLists(); }

function openCustomiser(type, index){
    if(gameRunning) return;
    editType = type; editIndex = index;
    const obj = type==='ball' ? balls[index] : powerups[index];
    editCopy = JSON.parse(JSON.stringify(obj)); // shallow copy props
    if(type==='ball') editCopy.weapon = {...balls[index].weapon}; // deep copy weapon
    
    customiserModal.style.display = 'flex';
    
    const tabsContainer = document.querySelector('.custom-tabs');
    tabsContainer.innerHTML = '';
    
    const tabNames = type==='ball' ? ['Stats','Loadout','Paint'] : ['Effect','Shape','Paint'];
    tabNames.forEach((name, i) => {
        const t = document.createElement('div');
        t.className = `custom-tab ${i===0?'active':''}`;
        t.textContent = name;
        t.onclick = () => {
            document.querySelectorAll('.custom-tab').forEach(x=>x.classList.remove('active'));
            t.classList.add('active');
            renderCustomBody(name);
        };
        tabsContainer.appendChild(t);
    });
    
    renderCustomBody(tabNames[0]);
    renderCustomPreview();
}

function renderCustomBody(tab){
    customBody.innerHTML = '';
    
    if(editType === 'ball'){
        if(tab === 'Stats'){
            customBody.innerHTML = `
                <div class="control"><label class="setting-label">Name</label><input type="text" id="cName" value="${editCopy.name}"></div>
                <div class="control"><label class="setting-label">Max HP</label><input type="number" id="cHP" value="${editCopy.maxHp}"></div>
            `;
            document.getElementById('cName').oninput = e => { editCopy.name = e.target.value; renderCustomPreview(); };
            document.getElementById('cHP').oninput = e => editCopy.maxHp = parseFloat(e.target.value);
        }
        else if(tab === 'Loadout'){
            customBody.innerHTML = `
                <div class="control"><label class="setting-label">Damage</label><input type="number" id="cDmg" value="${editCopy.weapon.damage}"></div>
                <div class="control"><label class="setting-label">Orbit Speed</label><input type="number" id="cSpd" value="${editCopy.weapon.speed}"></div>
            `;
            document.getElementById('cDmg').oninput = e => editCopy.weapon.damage = parseFloat(e.target.value);
            document.getElementById('cSpd').oninput = e => editCopy.weapon.speed = parseFloat(e.target.value);
        }
        else if(tab === 'Paint'){
            renderColorGrid();
        }
    } 
    else { // Powerup
        if(tab === 'Effect'){
            customBody.innerHTML = `
                <div class="control"><label class="setting-label">Effect Type</label>
                <select id="cType">
                    <option value="HEAL" ${editCopy.type==='HEAL'?'selected':''}>HEAL (Restore HP)</option>
                    <option value="RAGE" ${editCopy.type==='RAGE'?'selected':''}>RAGE (Dmg Up)</option>
                    <option value="SPEED" ${editCopy.type==='SPEED'?'selected':''}>HASTE (Speed Up)</option>
                </select></div>
            `;
            document.getElementById('cType').onchange = e => { editCopy.type = e.target.value; renderCustomPreview(); };
        }
        else if(tab === 'Shape'){
            customBody.innerHTML = `<div class="grid-container" id="shapeGrid"></div>`;
            const sg = document.getElementById('shapeGrid');
            SHAPES.forEach(s => {
                const d = document.createElement('div');
                d.className = `grid-item ${s.lock?'locked':''} ${editCopy.shape===s.id?'active':''}`;
                d.innerHTML = `<i class="fa-solid ${s.icon}"></i>`;
                if(!s.lock) d.onclick = () => { editCopy.shape = s.id; renderCustomBody('Shape'); renderCustomPreview(); };
                sg.appendChild(d);
            });
        }
        else if(tab === 'Paint'){
            renderColorGrid();
        }
    }
}

function renderColorGrid(){
    customBody.innerHTML = `<div class="control"><label class="setting-label">Select Color</label><div class="grid-container" id="cGrid"></div></div>`;
    const g = document.getElementById('cGrid');
    COLORS.forEach(col => {
        const d = document.createElement('div');
        d.className = `grid-item ${col.lock?'locked':''}`;
        d.style.backgroundColor = col.c;
        if(!col.lock) d.onclick = () => { editCopy.color = col.c; renderCustomPreview(); };
        g.appendChild(d);
    });
}

function renderCustomPreview(){
    if(editType === 'ball'){
        customPreview.className = 'preview-ball'; // reset
        customPreview.style.backgroundColor = editCopy.color;
        customPreview.style.borderRadius = '50%';
        customPreview.style.clipPath = 'none';
        customPreview.textContent = editCopy.name.charAt(0);
        customPreview.innerHTML = editCopy.name.charAt(0); // clear icons
    } else {
        customPreview.className = `preview-ball ${editCopy.shape}`;
        customPreview.style.backgroundColor = editCopy.color;
        customPreview.style.borderRadius = '0';
        if(editCopy.shape === 'shape-circle') customPreview.style.borderRadius = '50%';
        if(editCopy.shape === 'shape-square') customPreview.style.borderRadius = '4px';
        
        let icon = 'fa-heart';
        if(editCopy.type === 'RAGE') icon = 'fa-fire';
        if(editCopy.type === 'SPEED') icon = 'fa-bolt';
        customPreview.innerHTML = `<i class="fa-solid ${icon}"></i>`;
    }
}

confirmCustom.addEventListener('click', () => {
    if(editIndex!==null){
        const target = editType==='ball' ? balls[editIndex] : powerups[editIndex];
        Object.assign(target, editCopy); // Apply props
        if(editType === 'ball'){
             target.el.style.backgroundColor = target.color;
             target.weapon = editCopy.weapon;
        } else {
             target.el.className = `powerup-el ${target.shape}`;
             target.el.style.backgroundColor = target.color;
             target.el.innerHTML = '';
             const i = document.createElement('i'); i.className = target.getIcon();
             target.el.appendChild(i);
        }
        renderLists();
    }
    customiserModal.style.display = 'none';
});
cancelCustom.addEventListener('click', () => customiserModal.style.display = 'none');

/* ---- Utils ---- */
function setEditorLocked(lock){
    if(lock) editorOverlay.style.display = 'block';
    else editorOverlay.style.display = 'none';
    const elems = editor.querySelectorAll('input, select, button, .action-btn, .tab');
    elems.forEach(e => {
        if(e.id !== 'startStop') e.disabled = lock;
        if(lock) e.style.pointerEvents = (e.id==='startStop')?'auto':'none';
        else e.style.pointerEvents = 'auto';
    });
}
function hexToRgba(hex, a){
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16), g = parseInt(h.substring(2,4),16), b = parseInt(h.substring(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
}

init();

</script>
</body>
</html>